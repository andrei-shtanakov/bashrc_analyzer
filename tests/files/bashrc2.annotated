# .bashrc

# Source global definitions
if [ -f /etc/bashrc ]; then
   . /etc/bashrc
fi

# enable modules (this should replace ~/.modulerc method)
if test -d /usr/prog/modules/all; then
    module use /usr/prog/modules/all
    module load proxy/GLOBAL
#  AI: 1. Explanation: Loading modules in .bashrc makes them load for every shell, even non-interactive ones, which can slow down your work and lead to conflicts with other modules.
#  AI: 2. Consequences: This can impact the performance of your HPC tasks and cause unexpected behavior due to conflicting module configurations.
#  AI: 3. Fix: Move the "module load proxy/GLOBAL" line from .bashrc to .bash_profile or load modules interactively when needed to ensure they only load when necessary.
#  AI: 4. Tip: Remember to always check for module conflicts and dependencies when loading modules on HPC clusters to avoid issues with your computations.

fi
if test -d /cm/shared/modulefiles; then
    module use /cm/shared/modulefiles
fi
if test -d /cm/local/modulefiles; then
    module use /cm/local/modulefiles
fi
# enable Novartis Structural Biology modules
#if test -d /usr/prog/sb/modules; then
#    module use /usr/prog/sb/modules
#fi
# enable XTB/RESCOSS modules
if test -d /usr/prog/cadd/modules; then
    module use /usr/prog/cadd/modules
fi
# checking which storage tier my data is in:
#find /path/toFiles/ -type f > files.txt
#cat files.txt|xargs -l1 -I {}|/usr/prog/scicomp/check_tier/check_tier.sh "{}"

# modules for SBGrid
module use /programs/share/modulefiles/x86_64-linux


# User specific aliases and functions
# set proxy if needed (for wget, etc)
# export wget_proxy=http://usca-proxy01.na.novartis.net:2011
alias cls='clear;ls'
#alias gdcserver='adm_hornavi2@nrusca-sld0333.nibr.novartis.net'

#PS1="[\h:\W]$ "
#umask 022
umask 027

#export PATH=$PATH:/programs/x86_64-linux/grace/5.1.25/grace/bin
export PATH=$PATH:/home/golosan1/bin
#  AI: 1. Explanation: Hardcoding paths in your .bashrc file can lead to problems by prioritizing specific directories over system defaults, potentially causing conflicts with existing software or outdated libraries.
#  AI: 2. Consequences: This can result in errors, instability, or degraded performance when running programs that rely on system libraries or dependencies.
#  AI: 3. Fix example: To avoid hardcoded paths and potential issues, you can modify the PATH variable in your .bashrc file by appending the desired directory without overriding the existing PATH settings. For example, you can use "export PATH=$PATH:/home/user/my_software/bin" to add the directory without altering the existing PATH.
#  AI: 4. Tip: Consider using environment modules or virtual environments to manage software installations on HPC clusters, which can help avoid conflicts and ensure a more organized and efficient workflow.

export PYTHONPATH=~/bin:~/pythonmodules:~/local/lib/python3.6/site-packages:$PYTHONPATH
#  AI: 1. Explanation: When you use export PYTHONPATH=~/bin:~/pythonmodules:~/local/lib/python3.6/site-packages:$PYTHONPATH in your .bashrc file, you are not appending to the existing PYTHONPATH variable. This might overwrite important paths and lead to unexpected behavior.
#  AI: 2. Consequences: The consequences could include programs failing to find essential libraries or running with incorrect versions, potentially causing errors in your scientific computations.
#  AI: 3. Fix: To avoid overwriting system paths, you should modify the line to export PYTHONPATH=~/bin:~/pythonmodules:~/local/lib/python3.6/site-packages:$PYTHONPATH. This appends your custom paths to the existing PYTHONPATH without erasing important system paths.
#  AI: 4. Tip: When modifying environment variables like PATH or PYTHONPATH in your .bashrc file, always remember to use the append operator (:$PATH) to avoid accidentally deleting system paths. This will ensure that your custom paths are added without interfering with the system's functionality.



# set Gaussian scratch directory
#export GAUSS_SCRDIR=/clscratch/hornavi2

# source Structural Biology Grid (SBG) software environment
# something there overwrites my python module - that's a big no/go
#source /usr/prog/sbgrid/sbgrid.shrc

# load the modules you want
module load uge
#  AI: 1. When you load modules in your .bashrc file, it runs every time a new shell is opened, even for non-interactive tasks. This can slow down your work and lead to conflicts with other modules.
#  AI: 2. Loading modules in .bashrc can cause issues like errors, delays in shell startup, and conflicts between different modules that are being loaded repeatedly.
#  AI: 3. To fix this, move the "module load uge" line from your .bashrc file to your .bash_profile. This way, modules will only be loaded when you start an interactive shell, avoiding unnecessary loading in non-interactive shells.
#  AI: 4. Remember to always test your changes after modifying configuration files to ensure that everything is working as expected. It's also a good practice to keep your .bashrc file clean and only include essential configurations to avoid clutter and potential issues.

#module load OpenEye/20190305
#module load MOE/2019.0101
module load MOE/2022.02_site
#  AI: 1. When you load modules in your .bashrc file, it runs for every new shell, even non-interactive ones, which can slow down your work and lead to conflicts with other settings. It's not the best practice for managing modules on an HPC cluster.
#  AI: 2. This could cause delays in launching new shells, potential conflicts with other configurations, and make troubleshooting more difficult if issues arise.
#  AI: 3. To fix this, move the "module load MOE/2022.02_site" line from your .bashrc file to your .bash_profile or load modules interactively when needed. This way, modules will only be loaded when you start an interactive shell, reducing unnecessary loading for non-interactive shells.
#  AI: 4. Remember to always check with your cluster's documentation or system administrators for best practices on managing modules and configurations to optimize your HPC cluster usage.

# PyMOL 2.1.0.0 is matching VR PyMOL
#module load PyMOL/2.3.1
#module load sbgrid/pymol_schrodinger/2.3.1
#module load icm/3.87b
#module load icm-chemist/3.87b
#module load cosmologic
#module load Gaussian/09-foss-2018a
module load ccdc/2019.2
#  AI: 1. The problem with loading modules in your .bashrc file is that it gets executed every time a new shell is opened, even when it's not necessary. This can slow down your work and potentially lead to conflicts with other commands or settings.
#  AI: 2. Consequences of loading modules in .bashrc include longer shell startup times and potential conflicts with other configurations, leading to unexpected behavior in your HPC environment.
#  AI: 3. To fix this issue, you can move the module load command from your .bashrc file to your .bash_profile or load the modules interactively as needed. This way, modules will only be loaded when you actually need them, improving efficiency and reducing conflicts.
#  AI: 4. Remember to always check your environment settings and configuration files for any unnecessary commands or redundancies to optimize your HPC cluster usage. It's good practice to separate different types of configurations in the appropriate files to keep your system running smoothly.

#module load VMD/1.9.3-cuda80
module load MoKa/2.6.6
#  AI: 1. Loading modules in .bashrc slows down shell startup times for every new shell, even non-interactive ones. This can cause unnecessary delays in your work and lead to conflicts with other modules or settings.
#  AI: 2. The consequence of loading modules in .bashrc is that it can significantly slow down your workflow, especially when working with multiple shells or scripts. It can also lead to conflicts with other modules or configurations, resulting in unexpected errors.
#  AI: 3. To fix this issue, move the "module load MoKa/2.6.6" line from your .bashrc file to your .bash_profile. This way, the module will only be loaded when you start an interactive shell, avoiding unnecessary delays and potential conflicts.
#  AI: 4. Remember to always check for conflicting module loads or configurations before making changes to your .bashrc or .bash_profile files. This will help you avoid unexpected errors and ensure smooth operation of your HPC cluster environment.

#module load oraclient

# Amber16
# module load Amber

export PYTHONPATH=/usr/prog/amber/amber16-goolf-1.5.14-NX/lib/python2.7/site-packages:$PYTHONPATH
#  AI: 1. Explanation: By not appending $PATH to your custom path configurations, you risk overwriting important system paths. This means the system might not be able to find essential commands or libraries when needed.
#  AI: 2. Consequences: This could lead to programs failing to run, errors during compilation, or unexpected behavior in your HPC environment.
#  AI: 3. Fix example: To prevent overwriting system paths, modify your .bashrc line to include $PATH at the end. For example, change export PYTHONPATH=/usr/prog/amber/amber16-goolf-1.5.14-NX/lib/python2.7/site-packages:$PYTHONPATH to export PYTHONPATH=/usr/prog/amber/amber16-goolf-1.5.14-NX/lib/python2.7/site-packages:$PYTHONPATH:$PATH.
#  AI: 4. Additional tip: Always double-check your configuration changes to avoid unintentional disruptions to your HPC workflow. It's a good practice to back up your .bashrc file before making any modifications.


module load Amber/16-intel-2018a-AmberTools17-patchlevel-8.12-CUDA90
#  AI: 1. Loading modules in .bashrc can slow down the startup of every new shell, which isn't necessary for non-interactive shells like those used by batch jobs. It's better to load modules in .bash_profile or only when needed interactively.
#  AI: 2. This can cause unnecessary delays in running tasks, increase the likelihood of conflicts between different module versions, and clutter the environment with unnecessary configurations.
#  AI: 3. To fix this, move the "module load Amber/16-intel-2018a-AmberTools17-patchlevel-8.12-CUDA90" line from .bashrc to .bash_profile or load it only when needed interactively by typing the command in the shell.
#  AI: 4. Remember to check your module dependencies and unload any conflicting or unnecessary modules to keep your environment clean and efficient.


#module load Rosetta/3.10-foss-2018a
# this module has rdkit and also works with OEChem
#module load anaconda/3.6-cadd-2019.2
# the new 'joint' module:
#module load PythonDS

# there's a module for setting proxies:
# module load NIBR/proxies/USCA